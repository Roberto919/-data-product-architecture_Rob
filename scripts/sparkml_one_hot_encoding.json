{"paragraphs":[{"text":"%pyspark\n\nfrom pyspark.ml.feature import OneHotEncoder, StringIndexer\n\n# creamos nuestro set de datos de entrada categorico\ndf = spark.createDataFrame([\n    (0, \"a\"),\n    (1, \"b\"),\n    (2, \"c\"),\n    (3, \"a\"),\n    (4, \"a\"),\n    (5, \"c\")\n], [\"id\", \"category\"])\n\n# Esta funcion agrega un id numerico a cada valor diferente de un valor categorico \n# es como establecer los niveles en R de una factor pero los niveles son numericos,\n# sus id. El indice se establece por orden de frecuencia (descendente), por lo que \n# el indice 0 corresponde a la variable que aparece con mas frecuencia\nstring_indexer = StringIndexer(inputCol=\"category\", outputCol=\"categoryIndex\")\nmodel = string_indexer.fit(df)\nindexed = model.transform(df)\nindexed.show()\n","user":"anonymous","dateUpdated":"2020-03-31T22:11:53+0000","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/python"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"+---+--------+-------------+\n| id|category|categoryIndex|\n+---+--------+-------------+\n|  0|       a|          0.0|\n|  1|       b|          2.0|\n|  2|       c|          1.0|\n|  3|       a|          0.0|\n|  4|       a|          0.0|\n|  5|       c|          1.0|\n+---+--------+-------------+\n\n"}]},"apps":[],"jobName":"paragraph_1585692541717_1496405278","id":"20200331-220901_131044901","dateCreated":"2020-03-31T22:09:01+0000","dateStarted":"2020-03-31T22:11:53+0000","dateFinished":"2020-03-31T22:11:54+0000","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:6970"},{"text":"%pyspark\n\n# OneHotEncoder no tiene un fit ya que solo es un transformador\nencoder = OneHotEncoder(inputCol=\"categoryIndex\", outputCol=\"categoryVec\")\nencoded = encoder.transform(indexed)\nencoded.show()","user":"anonymous","dateUpdated":"2020-03-31T22:12:24+0000","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/python"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"+---+--------+-------------+-------------+\n| id|category|categoryIndex|  categoryVec|\n+---+--------+-------------+-------------+\n|  0|       a|          0.0|(2,[0],[1.0])|\n|  1|       b|          2.0|    (2,[],[])|\n|  2|       c|          1.0|(2,[1],[1.0])|\n|  3|       a|          0.0|(2,[0],[1.0])|\n|  4|       a|          0.0|(2,[0],[1.0])|\n|  5|       c|          1.0|(2,[1],[1.0])|\n+---+--------+-------------+-------------+\n\n"}]},"apps":[],"jobName":"paragraph_1585692713583_1615630443","id":"20200331-221153_917371718","dateCreated":"2020-03-31T22:11:53+0000","dateStarted":"2020-03-31T22:12:24+0000","dateFinished":"2020-03-31T22:12:25+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:6971"},{"text":"%pyspark\n","user":"anonymous","dateUpdated":"2020-03-31T22:12:24+0000","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1585692744983_503925874","id":"20200331-221224_1757990043","dateCreated":"2020-03-31T22:12:24+0000","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:6972"}],"name":"sparkml_one_hot_encoding","id":"2F5YFPWAD","noteParams":{},"noteForms":{},"angularObjects":{"md:shared_process":[],"spark:shared_process":[]},"config":{"isZeppelinNotebookCronEnable":false,"looknfeel":"default","personalizedMode":"false"},"info":{}}